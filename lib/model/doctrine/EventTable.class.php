<?php

/**
 * EventTable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class EventTable extends Wf_Doctrine_Table
{
  /**
   * Returns an instance of this class.
   *
   * @return object EventTable
   */
  public static function getInstance()
  {
    return Doctrine_Core::getTable('Event');
  }
  
  public function buildQueryForFilters(array $filters = array())
  {
    $query = Doctrine_Query::create()->from('Event ev INDEXBY ev.id')
      ->addSelect('ev.name, ev.min_cost, ev.max_cost, ev.event_type_id, ev.ticket_url')
      ->leftJoin('ev.Picture pic')
      ->addSelect('pic.type, pic.format, pic.slug, pic.width, pic.height, pic.title')  
      ->leftJoin('ev.Venue vn')
      ->addSelect('vn.name, vn.id')
      ->leftJoin('vn.Location lc')
      ->addSelect('lc.name, lc.root_id, lc.lft, lc.rgt')
      ->innerJoin('ev.EventOccurances eo')
      ->addSelect('eo.start_date, eo.end_date, eo.start_time, eo.end_time, eo.event_id, eo.ticket_url')
      ->groupBy('eo.id')
      ->addWhere('ev.is_published = TRUE')
      ->setHydrationMode(Doctrine::HYDRATE_ARRAY);    

    if ($filters)
    {
      foreach($filters as $filter => $value)
      {
        $method = sprintf('add%sFilterToQuery', ucfirst(sfInflector::camelize($filter)));
        if ($value && method_exists($this, $method))
        {
          $this->$method($query, $value, $filters);
        }
      }
    }

//    $query->echoBoundSqlQuery();
    return $query;
  }
  
  public function buildQueryForAdmin(Doctrine_Query $query)
  {
    $rootAlias = $query->getRootAlias();
    return $query->leftJoin($rootAlias . '.Venue vn');
  }
   
  public function addStartDateFilterToQuery(Doctrine_Query $query, DateTime $startDate)
  {
    $query->andWhere('eo.end_date >= ?', $startDate->format('Y-m-d'));
  }
  
  public function addEndDateFilterToQuery(Doctrine_Query $query,  DateTime $endDate)
  {
    $query->andWhere('eo.start_date <= ?', $endDate->format('Y-m-d'));
  }  
  
  public function addEventTypeFilterToQuery(Doctrine_Query $query, EventType $eventType)
  {
    $eventTypeIds = $eventType->getNode()->getCachedDescendantIds(null, true);
    $query->andWhereIn('ev.event_type_id', $eventTypeIds);
  }
  
  public function addDisciplineFilterToQuery(Doctrine_Query $query, Discipline $discipline)
  {
    if (!$query->contains('ev.EventDiscipline'))
    {
      $query->innerJoin('ev.EventDiscipline ed');
    }
    $disciplineIds = $discipline->getNode()->getCachedDescendantIds(null, true);
    $query->andWhereIn('ed.discipline_id', $disciplineIds);    
//    $disciplineIds = array();
//    foreach($disciplines as $discipline)
//    {
//      $disciplineIds = array_merge($disciplineIds, $discipline->getNode()->getCachedDescendantIds(null, true));
//    }
//    $query->andWhereIn('ed.discipline_id', array_unique($disciplineIds));
  }
  
  public function addLocationFilterToQuery(Doctrine_Query $query, Location $location)
  {
    $locationIds = $location->getNode()->getCachedDescendantIds(null, true);
    $query->andWhereIn('vn.location_id', $locationIds);
  }
  
  public function addProfileFilterToQuery(Doctrine_Query $query, Profile $profile, $filters)
  {
    if (isset($filters['include_members']) && $filters['include_members'])
    {
      $profiles = ProfileTable::getInstance()->findGroupMembers($profile);
      $profileIds = $profiles->getPrimaryKeys();
      array_unshift($profileIds, $profile->id);
      $query->innerJoin(sprintf('ev.EventProfile ep WITH ep.profile_id IN (%s)', implode(',', $profileIds)));
    }
    else
    {
      $query->innerJoin('ev.EventProfile ep WITH ep.profile_id = ?', $profile->id);      
    }
  }
  
  public function addVenueFilterToQuery(Doctrine_Query $query, Venue $venue)
  {
    $query->andWhere('ev.venue_id = ?', $venue->id);
  }
  
  public function addTagFilterToQuery(Doctrine_Query $query, Doctrine_Collection $tags)
  {
    if ($tags->count())
    {
      $query->innerJoin(sprintf('ev.EventTagging tg WITH tg.tag_id IN (%s)', implode(',', $tags->getPrimaryKeys())));
      if ($tags->count() > 1)
      {
        $query->addHaving('COUNT(DISTINCT tag_id) = ?', $tags->count());
      }
    }
  }
  
  public function addEventFilterToQuery(Doctrine_Query $query, Event $ev)
  {
    $query->andWhere('ev.id = ?', $ev->id);
  }
  
  public function addNameFilterToQuery(Doctrine_Query $query, $name)
  {
    $query
      ->addWhere('ev.name LIKE ?', '%' . $name . '%')
      ->addOrderBy('ev.name LIKE "' . $name . '%" DESC');
  }
  
  
  public function buildDateBasedQuery($startDate, $endDate)
  {
    return Doctrine_Query::create()->from('Event ev')
      ->innerJoin('ev.EventOccurances eo WITH eo.end_date >= ? AND eo.start_date <= ?', array($startDate, $endDate))
      ->select('ev.*')      
      ->addSelect('MIN(eo.start_date) AS start_date, MAX(eo.end_date) AS end_date')
      ->groupBy('ev.id')      
      ->orderBy('start_date ASC');    
  }
  
  public function buildUpcomingQuery()
  {
    return $this->buildDateBasedQuery(date('Y-m-d'), date('Y-m-d', strtotime('+3 months')));
  }
  
  public static function findObjectForShow($parameters = array())
  {
    return static::getInstance()->createQuery('ev')
      ->where('ev.id = ?', $parameters['id'])
      ->fetchOne();
  }
  
  /**
   * @param type $filters
   * @return integer
   */
  public function countForFilters($filters)
  {
    return $this->buildQueryForFilters($filters)->count();
  }
  
  /**
   * @return Event
   */
  public function findObjectForFilter($id)
  {
    return static::getInstance()->findOneById($id);
  }
  
  public function findLatestStartDateForFilters($filters)
  {
    $query = $this->buildQueryForFilters($filters);
    return $query
      ->select('MAX(eo.start_date)')
      ->setHydrationMode(Doctrine::HYDRATE_SINGLE_SCALAR)
      ->execute();
  }
  
  public function findUpcomingByProfile(Profile $pf)
  {
    $query = $this->buildUpcomingQuery();
    $query->innerJoin('ev.EventProfile epf WITH profile_id = ?', $pf->id);
    return $query->execute();
  }
  
  public function findPastByProfile(Profile $pf)
  {
    $query = $this->buildDateBasedQuery('2010-01-01', date('Y-m-d', strtotime('-1 day')));
    $query->innerJoin('ev.EventProfile epf WITH profile_id = ?', $pf->id);
    return $query->execute();
  }
  
  public function findUpcomingByVenue(Venue $vn)
  {
    $query = $this->buildUpcomingQuery();
    $query->andWhere('ev.venue_id = ?', $vn->id);
    return $query->execute();
  }
    
  public function pivotEventsForFilters($unpivotedEvents, $filters)
  {    
    $events = array();
    $collapsableEventTypeIds = $filters['include_past_events'] ? 
      EventTypeTable::getInstance()->findGalleryTreeIds() : 
      array();
    
    foreach($unpivotedEvents as $event)
    {
      if (!isset($event['EventOccurances']))
      {
        continue;
      }
      if (in_array($event['event_type_id'], $collapsableEventTypeIds)) //take the start and end, only
      {
        $firstDate = new DateTime(min(wfToolkit::arrayPluck($event['EventOccurances'], 'start_date')));
        $lastDate = new DateTime(max(wfToolkit::arrayPluck($event['EventOccurances'], 'end_date')));
        $dummyFields = array('start_time' => false, 'end_time' => false);
        $events[$firstDate->format('Y-m-d')][static::getEventSortKey($event)] = array_merge($event, $dummyFields, array(
            'name' => $event['name'] . ' (Begins)'
        ));
        $events[$lastDate->format('Y-m-d')][static::getEventSortKey($event)] = array_merge($event, $dummyFields, array(
            'name' => $event['name'] . ' (Ends)'
        ));
      }
      else //take everything
      {
        foreach($event['EventOccurances'] as $eventOccurance)
        {
          $startDate = $filters['start_date'] && $eventOccurance['start_date'] <= $filters['start_date']->format('Y-m-d') ? 
                         clone $filters['start_date'] :
                         new DateTime($eventOccurance['start_date']);
          $endDate = $filters['end_date'] && $eventOccurance['end_date'] > $filters['end_date']->format('Y-m-d') ? 
                       clone $filters['end_date'] :
                       new DateTime($eventOccurance['end_date']);

          for($startDate; $startDate <= $endDate; $startDate->modify('+1 day'))
          {
            $eventWithTime = array_merge($event, array(
                'start_time' => $eventOccurance['start_time'],
                'end_time' => $eventOccurance['end_time']
            ));          
            $events[$startDate->format('Y-m-d')][static::getEventSortKey($eventWithTime)] = $eventWithTime;
          }  
        }
      }
    }
    
    wfToolkit::recursiveSort($events, 'ksort');
    
    return $events;
  }
  
  protected static function getEventSortKey($event)
  {
    if (isset($event['start_time']) && $event['start_time'])
    {
      $prefix = $event['start_time'];
    }
    elseif (isset($event['Venue']) && isset($event['Venue']['Location']))
    {
      $preferredLocation = LocationTable::findOneByIdCached(sfConfig::get('app_location_secondary_id'));
      $eventLocation = $event['Venue']['Location'];
      $isDescendantOfPreferredLocation = ($eventLocation['root_id'] == $preferredLocation['root_id'] && 
                                  $eventLocation['lft'] > $preferredLocation['lft'] && $eventLocation['rgt'] < $preferredLocation['rgt']);
      $isEventWithAllDayLast = $event['event_type_id'] == sfConfig::get('app_event_type_time_last_id');
      $prefix = ($isEventWithAllDayLast ? 'z' : '0') . 
                  ($isDescendantOfPreferredLocation ? '0' : '1') . 
                  $eventLocation['name']; //events w/o time come first, events at special location come first of those
    }
    else //events without a time or location come last
    {
      $prefix = 'z';      
    }
    return $prefix . strtolower($event['name']); //name is tiebreaker
  }
  
  public static function isPivotedCollectionWithTimeOrCost($pivotedEvents)
  {
    $fields = array('start_time', 'min_cost', 'max_cost');
    foreach($pivotedEvents as $events)
    {
      foreach($fields as $field)
      {
        $values = wfToolkit::arrayPluck($events, $field);
        if (array_filter($values))
        {
          return true;
        }      
      }      
    }
    return false;
  }
}